import{W as F,u as T,G as E,X as V,Y as L,E as W,Z as $,e as H,$ as z,a0 as A,I as O,a1 as I,a2 as U,b as G,a3 as M,a4 as Q,a5 as Y,V as Z,Q as B,a6 as X}from"./BlLQ5Jyq.js";const J={trailing:!0};function k(a,e=25,o={}){if(o={...J,...o},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let i,n,y=[],r,t;const b=(d,h)=>(r=K(a,d,h),r.finally(()=>{if(r=null,o.trailing&&t&&!n){const g=b(d,t);return t=null,g}}),r),v=function(...d){return o.trailing&&(t=d),r||new Promise(h=>{const g=!n&&o.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const c=o.leading?i:b(this,d);t=null;for(const f of y)f(c);y=[]},e),g?(i=b(this,d),h(i)):y.push(h)})},s=d=>{d&&(clearTimeout(d),n=null)};return v.isPending=()=>!!n,v.cancel=()=>{s(n),y=[],t=null},v.flush=()=>{if(s(n),!t||r)return;const d=t;return t=null,b(this,d)},v}async function K(a,e,o){return await a.apply(e,o)}function sa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;aa(a[0],a[1])&&a.unshift(e);let[o,i,n={}]=a,y=!1;const r=E(()=>V(o));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=T();n.server??=!0,n.default??=ta,n.getCachedData??=R,n.lazy??=!1,n.immediate??=!0,n.deep??=L.deep,n.dedupe??="cancel",n._functionName,t._asyncData[r.value];function b(){const c={cause:"initial",dedupe:n.dedupe};return t._asyncData[r.value]?._init||(c.cachedData=n.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=x(t,r.value,i,n,c.cachedData)),()=>t._asyncData[r.value].execute(c)}const v=b(),s=t._asyncData[r.value];s._deps++;const d=n.server!==!1&&t.payload.serverRendered;{let c=function(u){const l=t._asyncData[u];l?._deps&&(l._deps--,l._deps===0&&l?._off())};const f=W();if(f&&d&&n.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const u=f._nuxtOnBeforeMountCbs;$(()=>{u.forEach(l=>{l()}),u.splice(0,u.length)}),H(()=>u.splice(0,u.length))}const p=f&&(f._nuxtClientOnly||z(A,!1));d&&t.isHydrating&&(s.error.value||s.data.value!==void 0)?s.status.value=s.error.value?"error":"success":f&&(!p&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?f._nuxtOnBeforeMountCbs.push(v):n.immediate&&s.status.value!=="success"&&v();const _=U(),D=O(r,(u,l)=>{if((u||l)&&u!==l){y=!0;const P=t._asyncData[l]?.data.value!==void 0,q=t._asyncDataPromises[l]!==void 0,S={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[u]?._init){let C;l&&P?C=t._asyncData[l].data.value:(C=n.getCachedData(u,t,{cause:"initial"}),S.cachedData=C),t._asyncData[u]=x(t,u,i,n,C)}t._asyncData[u]._deps++,l&&c(l),(n.immediate||P||q)&&t._asyncData[u].execute(S),X(()=>{y=!1})}},{flush:"sync"}),m=n.watch?O(n.watch,()=>{y||s._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};_&&I(()=>{D(),m(),c(r.value)})}const h={data:w(()=>t._asyncData[r.value]?.data),pending:w(()=>t._asyncData[r.value]?.pending),status:w(()=>t._asyncData[r.value]?.status),error:w(()=>t._asyncData[r.value]?.error),refresh:(...c)=>t._asyncData[r.value]?._init?t._asyncData[r.value].execute(...c):b()(),execute:(...c)=>h.refresh(...c),clear:()=>{const c=t._asyncData[r.value];if(c?._abortController)try{c._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{c._abortController=void 0}N(t,r.value)}},g=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>h);return Object.assign(g,h),g}function w(a){return E({get(){return a()?.value},set(e){const o=a();o&&(o.value=e)}})}function aa(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}async function oa(a){await new Promise(o=>F(o)),await T().hooks.callHookParallel("app:data:refresh",void 0)}function N(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=B(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function ea(a,e){const o={};for(const i of e)o[i]=a[i];return o}function x(a,e,o,i,n){a.payload._errors[e]??=void 0;const y=i.getCachedData!==R,r=o,t=i.deep?G:M,b=n!==void 0,v=a.hook("app:data:refresh",async d=>{(!d||d.includes(e))&&await s.execute({cause:"refresh:hook"})}),s={data:t(b?n:i.default()),pending:E(()=>s.status.value==="pending"),error:Q(a.payload._errors,e),status:M("idle"),execute:(...d)=>{const[h,g=void 0]=d,c=h&&g===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]&&(c.dedupe??i.dedupe)==="defer")return a._asyncDataPromises[e];{const _="cachedData"in c?c.cachedData:i.getCachedData(e,a,{cause:c.cause??"refresh:manual"});if(_!==void 0)return a.payload.data[e]=s.data.value=_,s.error.value=void 0,s.status.value="success",Promise.resolve(_)}s._abortController&&s._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),s._abortController=new AbortController,s.status.value="pending";const f=new AbortController,p=new Promise((_,D)=>{try{const m=c.timeout??i.timeout,u=na([s._abortController?.signal,c?.signal],f.signal,m);if(u.aborted){const l=u.reason;D(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"));return}return u.addEventListener("abort",()=>{const l=u.reason;D(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"))},{once:!0,signal:f.signal}),Promise.resolve(r(a,{signal:u})).then(_,D)}catch(m){D(m)}}).then(async _=>{let D=_;i.transform&&(D=await i.transform(_)),i.pick&&(D=ea(D,i.pick)),a.payload.data[e]=D,s.data.value=D,s.error.value=void 0,s.status.value="success"}).catch(_=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==p)&&!s._abortController?.signal.aborted){if(typeof DOMException<"u"&&_ instanceof DOMException&&_.name==="AbortError"){s.status.value="idle";return}s.error.value=Z(_),s.data.value=B(i.default()),s.status.value="error"}}).finally(()=>{f.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=p,a._asyncDataPromises[e]},_execute:k((...d)=>s.execute(...d),0,{leading:!0}),_default:i.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{v(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),y||Y(()=>{a._asyncData[e]?._init||(N(a,e),s.execute=()=>Promise.resolve())})}};return s}const ta=()=>{},R=(a,e,o)=>{if(e.isHydrating)return e.payload.data[a];if(o.cause!=="refresh:manual"&&o.cause!=="refresh:hook")return e.static.data[a]};function na(a,e,o){const i=a.filter(r=>!!r);if(typeof o=="number"&&o>=0){const r=AbortSignal.timeout?.(o);r&&i.push(r)}if(AbortSignal.any)return AbortSignal.any(i);const n=new AbortController;for(const r of i)if(r.aborted){const t=r.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const y=()=>{const t=i.find(b=>b.aborted)?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const r of i)r.addEventListener?.("abort",y,{once:!0,signal:e});return n.signal}const j={content:"v3.5.0--ZdTg81-z9wNaY3gdkrWmybjb-V5BBuL6sF4PB0xbDSM"},ia={content:"_content_content",info:"_content_info"},ca={content:{type:"page",fields:{id:"string",title:"string",body:"json",description:"string",extension:"string",meta:"json",navigation:"json",path:"string",seo:"json",stem:"string"}},info:{type:"data",fields:{}}};async function la(a,e){return await $fetch(`/__nuxt_content/${e}/sql_dump.txt`,{context:{},responseType:"text",headers:{"content-type":"text/plain"},query:{v:j[String(e)],t:void 0}})}async function ua(a,e,o){return await $fetch(`/__nuxt_content/${e}/query`,{context:a?{cloudflare:a.context.cloudflare}:{},headers:{"content-type":"application/json",...a?.node?.req?.headers?.cookie?{cookie:a.node.req.headers.cookie}:{}},query:{v:j[String(e)],t:void 0},method:"POST",body:{sql:o}})}export{j as a,la as b,ca as c,ua as f,oa as r,ia as t,sa as u};
